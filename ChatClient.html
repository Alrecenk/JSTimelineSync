<!doctype html>
<html lang="en">

<head>
<meta charset="UTF-8">
<script type="text/javascript" src="InterfaceButton.js"></script>

<script type="text/javascript" src="timeline_core/TObject.js"></script>
<script type="text/javascript" src="timeline_core/TEvent.js"></script>
<script type="text/javascript" src="timeline_core/Timeline.js"></script>
<script type="text/javascript" src="timeline_core/AddObject.js"></script>
<script type="text/javascript" src="timeline_core/TClient.js"></script>

<script type="text/javascript" src="objects/Player.js"></script>
<script type="text/javascript" src="objects/ChatLog.js"></script>

<script type="text/javascript" src="events/MovePlayer.js"></script>
<script type="text/javascript" src="events/AddChatLine.js"></script>
<script type="text/javascript" src="events/UpdatePlayerVelocity.js"></script>



<script type="text/javascript">

// Written by @Alrecenk who probably won't complain if you want to send him money.

window.addEventListener("load", windowLoadHandler, false);

var timeline_socket ;
var timeline;
var debug_timeline ;
var port = 8081;
var current_time = 0 ;
var interval = 1/60.0;

var my_id = -1 ;
var player_radius = 40;
var player_speed = 1000;
var player_fill = "#D0D0D0";
var player_stroke = "#D000D0" ;
var stroke_size = 4 ;

var connected = false;

function windowLoadHandler() {
    timeline = new Timeline();
    debug_timeline = new Timeline();
    timeline_socket = new TClient(timeline, 8081);

	// Any stuff you want to to before the canvas app is loaded goes here.
	canvasApp();
}

function canvasApp() {
	//The canvas this app is running on.
	var theCanvas = document.getElementById("canvasOne");
	// Comtext you can use to draw on.
	var context = theCanvas.getContext("2d");
	// Mouse position
	var mouse_x;
	var mouse_y;
	// Where the mouse was last pressed down.
	var down_mouse_x;
	var down_mouse_y;
	//Whether the mouse is currently down.
	var mouse_down = false ;
	//Which button is down (0 is left, 2 is right)
	var mouse_button ;
	
	var interface_buttons = {}; // Map of from name to buttons currently on the interface.
	
	
	function init() {
		setupGame()
		theCanvas.addEventListener("mousedown", mouseDownListener, false);
		window.addEventListener("mousemove", mouseMoveListener, false);
		window.addEventListener("mouseup", mouseUpListener, false);
		window.addEventListener('keydown',keyListener,false);
		setInterval(timeListener, 1000*interval); // Timer
	}
	
	function setupGame(){
		// Initialization stuff for canvas app goes here.
        my_id = timeline.getNextID(); // TODO race condition: this will be wrong if some other addObject event gets in before this one runs
		let player = new Player();
        player.x = 200 ;
        player.y = 200 ;
        player.name = "player " + my_id  ; // TODO let the player input this
        
        timeline.addObject(player, current_time) ;
        timeline.addEvent(new MovePlayer(current_time+0.1, {player_id:my_id, interval:interval }));
	}
	
	
	function drawScreen() {
		//bg
		context.fillStyle = "#000000";
		context.fillRect(0,0,theCanvas.width,theCanvas.height);
		
		// Draw any buttons currently on the interface.
		for (var button_name in interface_buttons) {
	        if (interface_buttons.hasOwnProperty(button_name)) {
	        	interface_buttons[button_name].draw(context);
	        }
	    }

        let IDs = timeline.getAllIDs() ; // TODO way to fetch things by groups?
        //console.log(IDs)
        for(let id in IDs){
            let p = timeline.get(id) ;
            if(p==null){
                continue ; //TODO print error
            }
            if(p.constructor.name == "Player"){
                drawCircle(p.x, p.y, player_radius, player_fill, player_stroke,stroke_size);
            }
            if(p.constructor.name == "ChatLog"){
                //TODO draw chat
            }
        }
		
	}
	
	function timeListener(){
        
        if(!connected && timeline_socket.ready()){
            timeline_socket.send("Hello from web client!");
            connected = true ;
        }

        if(mouse_down){
			let vx = 0 ; // if click invalid then default to stop
            let vy = 0 ;
            let me = timeline.get(my_id);
            let dx = mouse_x - me.x;
            let dy = mouse_y - me.y;
            let d2 = dx*dx+ dy*dy ;
            if(d2 > player_radius*player_radius){ // not clicking on self
                let d1 = Math.sqrt(d2);
                vx = dx * player_speed/d1;
                vy = dy * player_speed/d1;
            }
            timeline.addEvent(new UpdatePlayerVelocity(current_time,  {player_id:my_id, vx:vx, vy:vy})) ;
		}


        current_time += interval ;

        timeline.executeToTime(current_time);
        timeline.advanceBaseTime(current_time-3);
        //console.log(timeline);
		// Draw screen.
		drawScreen();
	}
	
	function keyListener(evt) {
		evt = evt || window.event;
	    var key_code = evt.keyCode || evt.which;
	    var character = String.fromCharCode(key_code); // This only works with letters. Unpredictable otherwise.
	    
        
        // TODO update chat line and submit on enter

        if(key_code == 37 || character == "A"){ // Left
	    	
	    }else if(key_code == 38 || character == "W"){// Up
	    	
	    }else if(key_code == 39 || character == "D" ){// Right
	    	
	    }else if(key_code == 40 || character == "S"){// Down
	    	
            //console.log("Debug hash data:");
            //console.log(debug_hash_data);
            //let hash_data = timeline.getHashData(current_time - 1) ;
            //console.log("Timeline hash data:");
            //console.log(hash_data);

            console.log("Debug timeline before update:");
            console.log(debug_timeline);

            let debug_hash_data = debug_timeline.getHashData(current_time - 1);
            let update = timeline.getUpdateFor(debug_hash_data);
            console.log("Debug timeline update:");
            console.log(update);

            debug_timeline.applyUpdate(update, true);
            console.log("Debug timeline after update:");
            console.log(debug_timeline);

	    }
	}
	
	function mouseDownListener(evt) {
		var bRect = theCanvas.getBoundingClientRect();
		mouse_down_x = (evt.clientX - bRect.left)*(theCanvas.width/bRect.width);
		mouse_down_y = (evt.clientY - bRect.top)*(theCanvas.height/bRect.height);
		mouse_down = true ;
		mouse_button = evt.button ;
        let vx = 0 ; // if click invalid then default to stop
        let vy = 0 ;
        let me = timeline.get(my_id);
        let dx = mouse_down_x - me.x;
        let dy = mouse_down_y - me.y;
        let d2 = dx*dx+ dy*dy ;
        if(d2 > player_radius*player_radius){ // not clicking on self
            let d1 = Math.sqrt(d2);
            vx = dx * player_speed/d1;
            vy = dy * player_speed/d1;
        }
        
        timeline.addEvent(new UpdatePlayerVelocity(current_time, {player_id:my_id, vx:vx, vy:vy})) ;
	}
	
	function mouseUpListener(evt) {
		mouse_down = false ;
		// Execute any buttons "clicked" (mouse up and down on the button)
		for (var button_name in interface_buttons) {
            if (interface_buttons.hasOwnProperty(button_name)) {
                var b = interface_buttons[button_name];
                if(b.inside(mouse_x, mouse_y) && b.inside(mouse_down_x, mouse_down_y)){
                    b.execute();
                }
            }
        }
		
        // Stop on mouse release
		timeline.addEvent(new UpdatePlayerVelocity(current_time,  {player_id:my_id, vx:0, vy:0})) ;


	}

	function mouseMoveListener(evt) {
		//getting mouse position correctly 
		var bRect = theCanvas.getBoundingClientRect();
		mouse_x = (evt.clientX - bRect.left)*(theCanvas.width/bRect.width);
		mouse_y = (evt.clientY - bRect.top)*(theCanvas.height/bRect.height);
		
		
	}
	
	// Draw a canvas line with a single call.
	function drawLine(color, size, x1, y1, x2, y2){
	    context.beginPath();
	    context.lineWidth = size;
	    context.strokeStyle = color;// set line color
	    context.moveTo(x1, y1);
	    context.lineTo(x2, y2);
	    context.stroke();
    }
	
	//Draw a canvas circle with a single call.
	//Use null for fill or stroke color if you do not wish to draw that element.
	function drawCircle(x, y, radius, fill_color, stroke_color, stroke_size){
		context.beginPath();
		context.arc(x, y, radius, 0, 2 * Math.PI, false);
		context.closePath();
		if(fill_color != null){
			context.fillStyle = fill_color;
			context.fill();
		}
		if(stroke_color != null){
			context.lineWidth = stroke_size;
			context.strokeStyle = stroke_color;
			context.stroke();
		}
	}	
	


	init(); // Start the canvasApp.
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

</script>
</head>
<body>
	<div style="top: 50px; text-align: center">
		<canvas id="canvasOne" width="1280" height="720"
			oncontextmenu="return false;">
			Your browser does not support HTML5 canvas.
		</canvas><br>
		
	</div>
</body>
</html>
