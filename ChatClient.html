<!doctype html>
<html lang="en">

<head>
<meta charset="UTF-8">
<script type="text/javascript" src="InterfaceButton.js"></script>
<script type="text/javascript">

// Written by @Alrecenk who probably won't complain if you want to send him money.

window.addEventListener("load", windowLoadHandler, false);

var timeline_socket ;
var timeline;
var port = 8081;
var interval = 1/60.0;

var my_name = "";
var my_id = -1 ;


function windowLoadHandler() {
    timeline = new TimeLine();
    timeline_socket = new TClient(timeline, 8081);

	// Any stuff you want to to before the canvas app is loaded goes here.
	canvasApp();
}

function canvasApp() {
	//The canvas this app is running on.
	var theCanvas = document.getElementById("canvasOne");
	// Comtext you can use to draw on.
	var context = theCanvas.getContext("2d");
	// Mouse position
	var mouse_x;
	var mouse_y;
	// Where the mouse was last pressed down.
	var down_mouse_x;
	var down_mouse_y;
	//Whether the mouse is currently down.
	var mouse_down = false ;
	//Which button is down (0 is left, 2 is right)
	var mouse_button ;
	
	var interface_buttons = {}; // Map of from name to buttons currently on the interface.
	
	
	function init() {
		setupGame()
		theCanvas.addEventListener("mousedown", mouseDownListener, false);
		window.addEventListener("mousemove", mouseMoveListener, false);
		window.addEventListener("mouseup", mouseUpListener, false);
		window.addEventListener('keydown',keyListener,false);
		setInterval(timeListener, 1000*interval); // Timer
	}
	
	function setupGame(){
		// Initialization stuff for canvas app goes here.
        my_id = timeline.getNextID(); // TODO could be a race condition if a remote object egts an ID at the same time?
        my_name = "player " + my_id  ; // TODO let the player input this
		timeline.addObject(new Player(my_name), timeline.current_time) ;
        timeline.addEvent(new MovePlayer(timeline.current_time, my_id, interval));
	}
	
	
	function drawScreen() {
		//bg
		context.fillStyle = "#000000";
		context.fillRect(0,0,theCanvas.width,theCanvas.height);
		
		// Draw any buttons currently on the interface.
		for (var button_name in interface_buttons) {
	        if (interface_buttons.hasOwnProperty(button_name)) {
	        	interface_buttons[button_name].draw(context);
	        }
	    }

        let IDs = timeline.getAllIDs() ; // TODO way to fetch things by groups?

        for(let id in IDs){
            let p = timeline.get(id) ;
            if(p.constructor.name == "Player"){
                drawCircle(p.x, p.y, player_radius, player_fill, player_stroke,stroke_size);
            }
            if(p.constructor.name == "ChatLog"){
                //TODO draw chat
            }
        }
		
	}
	
	function timeListener(){
        timeline.advanceCurrentTime(interval);
		// Draw screen.
		drawScreen();
	}
	
	function keyListener(evt) {
		evt = evt || window.event;
	    var key_code = evt.keyCode || evt.which;
	    var character = String.fromCharCode(key_code); // This only works with letters. Unpredictable otherwise.
	    
        
        // TODO update chat line and submit on enter

        if(key_code == 37 || character == "A"){ // Left
	    	
	    }else if(key_code == 38 || character == "W"){// Up
	    	
	    }else if(key_code == 39 || character == "D" ){// Right
	    	
	    }else if(key_code == 40 || character == "S"){// Down
	    	
	    }
	}
	
	function mouseDownListener(evt) {
		var bRect = theCanvas.getBoundingClientRect();
		mouse_down_x = (evt.clientX - bRect.left)*(theCanvas.width/bRect.width);
		mouse_down_y = (evt.clientY - bRect.top)*(theCanvas.height/bRect.height);
		mouse_down = true ;
		mouse_button = evt.button ;
        let vx = 0 ; // if click invalid then default to stop
        let vy = 0 ;
        let me = timeline.get(my_id);
        let dx = mouse_down_x - me.x;
        let dy = mouse_down_y - me.y;
        let d2 = dx*dx+ dy*dy ;
        if(d2 > player_radius*player_radius){ // not clicking on self
            let d1 = sqrt(d2);
            let vx = dx * player_speed/d1;
            let vy = dy * player_speed/d1;
            timeline.addEvent(new UpdatePlayerVelocity(timeline.current_time, my_id, vx, vy)) ;
        }
	}
	
	function mouseUpListener(evt) {
		mouse_down = false ;
		// Execute any buttons "clicked" (mouse up and down on the button)
		for (var button_name in interface_buttons) {
            if (interface_buttons.hasOwnProperty(button_name)) {
                var b = interface_buttons[button_name];
                if(b.inside(mouse_x, mouse_y) && b.inside(mouse_down_x, mouse_down_y)){
                    b.execute();
                }
            }
        }
		
        // Stop on mouse release
		timeline.addEvent(new UpdatePlayerVelocity(timeline.current_time, my_id, 0, 0)) ;


	}

	function mouseMoveListener(evt) {
		//getting mouse position correctly 
		var bRect = theCanvas.getBoundingClientRect();
		mouse_x = (evt.clientX - bRect.left)*(theCanvas.width/bRect.width);
		mouse_y = (evt.clientY - bRect.top)*(theCanvas.height/bRect.height);
		
		if(mouse_down){
			let vx = 0 ; // if click invalid then default to stop
            let vy = 0 ;
            let me = timeline.get(my_id);
            let dx = mouse_x - me.x;
            let dy = mouse_y - me.y;
            let d2 = dx*dx+ dy*dy ;
            if(d2 > player_radius*player_radius){ // not clicking on self
                let d1 = sqrt(d2);
                let vx = dx * player_speed/d1;
                let vy = dy * player_speed/d1;
                timeline.addEvent(new UpdatePlayerVelocity(timeline.current_time, my_id, vx, vy)) ;
            }
            
		}
	}
	
	// Draw a canvas line with a single call.
	function drawLine(color, size, x1, y1, x2, y2){
	    context.beginPath();
	    context.lineWidth = size;
	    context.strokeStyle = color;// set line color
	    context.moveTo(x1, y1);
	    context.lineTo(x2, y2);
	    context.stroke();
    }
	
	//Draw a canvas circle with a single call.
	//Use null for fill or stroke color if you do not wish to draw that element.
	function drawCircle(x, y, radius, fill_color, stroke_color, stroke_size){
		context.beginPath();
		context.arc(x, y, radius, 0, 2 * Math.PI, false);
		context.closePath();
		if(fill_color != null){
			context.fillStyle = fill_color;
			context.fill();
		}
		if(stroke_color != null){
			context.lineWidth = stroke_size;
			context.strokeStyle = stroke_color;
			context.stroke();
		}
	}	
	
	init(); // Start the canvasApp.
}

</script>
</head>
<body>
	<div style="top: 50px; text-align: center">
		<canvas id="canvasOne" width="1280" height="720"
			oncontextmenu="return false;">
			Your browser does not support HTML5 canvas.
		</canvas><br>
		
	</div>
</body>
</html>
